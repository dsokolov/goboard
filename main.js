/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GoPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/settings.ts
var DEFAULT_SETTINGS = {
  boardSize: 19,
  stoneSizeRatio: 0.9,
  // 40% от размера ячейки
  lineWidth: 1,
  backgroundColor: "#DCB35C",
  lineColor: "#000000",
  blackStoneColor: "#000000",
  whiteStoneColor: "#FFFFFF",
  showCoordinates: true,
  // по умолчанию координаты включены
  coordinatesColor: "#666666",
  // серый цвет для координат
  coordinatesFontSize: 12
  // размер шрифта координат
};

// src/renderer.ts
var GoBoardRenderer = class {
  constructor(settings) {
    this.settings = settings;
  }
  render(source, containerEl) {
    const game = this.parseGame(source);
    const svg = this.generateSVG(game);
    containerEl.appendChild(svg);
  }
  parseGame(source) {
    const lines = source.trim().split("\n");
    const moves = [];
    let moveNumber = 1;
    let boardSize = this.settings.boardSize;
    let showCoordinates = this.settings.showCoordinates;
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed)
        continue;
      const sizeMatch = trimmed.match(/^size\s+(\d+)x(\d+)$/i);
      if (sizeMatch) {
        const size = parseInt(sizeMatch[1]);
        boardSize = size;
        continue;
      }
      if (trimmed.toLowerCase() === "coordinates on") {
        showCoordinates = true;
        continue;
      }
      if (trimmed.toLowerCase() === "coordinates off") {
        showCoordinates = false;
        continue;
      }
      const match = trimmed.match(/^([BW])\s+([A-T]\d+)$/i);
      if (match) {
        const color = match[1].toUpperCase() === "B" ? "black" : "white";
        const position = match[2].toUpperCase();
        moves.push({
          stone: { color, position },
          moveNumber: moveNumber++
        });
      }
    }
    return {
      moves,
      boardSize,
      showCoordinates
    };
  }
  generateSVG(game) {
    const size = 400;
    const cellSize = size / (game.boardSize + 1);
    const stoneRadius = cellSize * this.settings.stoneSizeRatio / 2;
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("width", size.toString());
    svg.setAttribute("height", size.toString());
    svg.setAttribute("viewBox", `0 0 ${size} ${size}`);
    const background = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    background.setAttribute("width", size.toString());
    background.setAttribute("height", size.toString());
    background.setAttribute("fill", this.settings.backgroundColor);
    svg.appendChild(background);
    for (let i = 1; i <= game.boardSize; i++) {
      const pos = i * cellSize;
      const vLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
      vLine.setAttribute("x1", pos.toString());
      vLine.setAttribute("y1", cellSize.toString());
      vLine.setAttribute("x2", pos.toString());
      vLine.setAttribute("y2", (game.boardSize * cellSize).toString());
      vLine.setAttribute("stroke", this.settings.lineColor);
      vLine.setAttribute("stroke-width", this.settings.lineWidth.toString());
      svg.appendChild(vLine);
      const hLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
      hLine.setAttribute("x1", cellSize.toString());
      hLine.setAttribute("y1", pos.toString());
      hLine.setAttribute("x2", (game.boardSize * cellSize).toString());
      hLine.setAttribute("y2", pos.toString());
      hLine.setAttribute("stroke", this.settings.lineColor);
      hLine.setAttribute("stroke-width", this.settings.lineWidth.toString());
      svg.appendChild(hLine);
    }
    if (game.showCoordinates) {
      this.addCoordinates(svg, game.boardSize, cellSize);
    }
    for (const move of game.moves) {
      const pos = this.positionToCoords(move.stone.position, game.boardSize);
      if (pos) {
        const x = (pos.x + 1) * cellSize;
        const y = (pos.y + 1) * cellSize;
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", x.toString());
        circle.setAttribute("cy", y.toString());
        circle.setAttribute("r", stoneRadius.toString());
        circle.setAttribute("fill", move.stone.color === "black" ? this.settings.blackStoneColor : this.settings.whiteStoneColor);
        circle.setAttribute("stroke", this.settings.lineColor);
        circle.setAttribute("stroke-width", "1");
        svg.appendChild(circle);
      }
    }
    return svg;
  }
  addCoordinates(svg, boardSize, cellSize) {
    for (let i = 0; i < boardSize; i++) {
      const x = (i + 1) * cellSize;
      const y = cellSize * 0.5;
      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      text.setAttribute("x", x.toString());
      text.setAttribute("y", y.toString());
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("dominant-baseline", "middle");
      text.setAttribute("font-size", this.settings.coordinatesFontSize.toString());
      text.setAttribute("fill", this.settings.coordinatesColor);
      text.setAttribute("font-family", "Arial, sans-serif");
      text.textContent = String.fromCharCode("A".charCodeAt(0) + i);
      svg.appendChild(text);
    }
    for (let i = 0; i < boardSize; i++) {
      const x = cellSize * 0.5;
      const y = (i + 1) * cellSize;
      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      text.setAttribute("x", x.toString());
      text.setAttribute("y", y.toString());
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("dominant-baseline", "middle");
      text.setAttribute("font-size", this.settings.coordinatesFontSize.toString());
      text.setAttribute("fill", this.settings.coordinatesColor);
      text.setAttribute("font-family", "Arial, sans-serif");
      text.textContent = (i + 1).toString();
      svg.appendChild(text);
    }
  }
  positionToCoords(position, boardSize) {
    const letter = position.charAt(0);
    const number = parseInt(position.slice(1));
    const x = letter.charCodeAt(0) - "A".charCodeAt(0);
    const y = number - 1;
    if (x >= 0 && x < boardSize && y >= 0 && y < boardSize) {
      return { x, y };
    }
    return null;
  }
};

// src/main.ts
var GoPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.renderer = new GoBoardRenderer(this.settings);
    this.registerMarkdownCodeBlockProcessor("goboard", (source, el, ctx) => {
      this.renderer.render(source, el);
    });
    this.addSettingTab(new GoSettingsTab(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.renderer = new GoBoardRenderer(this.settings);
  }
};
var GoSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "GoBoard Settings" });
    new import_obsidian.Setting(containerEl).setName("Board Size").setDesc("Default board size (9, 13, or 19)").addDropdown((dropdown) => dropdown.addOption("9", "9x9").addOption("13", "13x13").addOption("19", "19x19").setValue(this.plugin.settings.boardSize.toString()).onChange(async (value) => {
      this.plugin.settings.boardSize = parseInt(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Stone Size Ratio").setDesc("Size of stones relative to cell size (0.1-1.0)").addSlider((slider) => slider.setLimits(0.1, 1, 0.1).setValue(this.plugin.settings.stoneSizeRatio).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.stoneSizeRatio = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Line Width").setDesc("Thickness of board lines").addSlider((slider) => slider.setLimits(0.5, 3, 0.5).setValue(this.plugin.settings.lineWidth).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.lineWidth = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Background Color").setDesc("Color of the board background").addColorPicker((colorPicker) => colorPicker.setValue(this.plugin.settings.backgroundColor).onChange(async (value) => {
      this.plugin.settings.backgroundColor = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Line Color").setDesc("Color of the board lines").addColorPicker((colorPicker) => colorPicker.setValue(this.plugin.settings.lineColor).onChange(async (value) => {
      this.plugin.settings.lineColor = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Black Stone Color").setDesc("Color of black stones").addColorPicker((colorPicker) => colorPicker.setValue(this.plugin.settings.blackStoneColor).onChange(async (value) => {
      this.plugin.settings.blackStoneColor = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("White Stone Color").setDesc("Color of white stones").addColorPicker((colorPicker) => colorPicker.setValue(this.plugin.settings.whiteStoneColor).onChange(async (value) => {
      this.plugin.settings.whiteStoneColor = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show Coordinates").setDesc("Display coordinates on the board").addToggle((toggle) => toggle.setValue(this.plugin.settings.showCoordinates).onChange(async (value) => {
      this.plugin.settings.showCoordinates = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Coordinates Color").setDesc("Color of coordinate labels").addColorPicker((colorPicker) => colorPicker.setValue(this.plugin.settings.coordinatesColor).onChange(async (value) => {
      this.plugin.settings.coordinatesColor = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Coordinates Font Size").setDesc("Font size of coordinate labels").addSlider((slider) => slider.setLimits(8, 20, 1).setValue(this.plugin.settings.coordinatesFontSize).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.coordinatesFontSize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Reset to Defaults").setDesc("Reset all settings to default values").addButton((button) => button.setButtonText("Reset").setCta().onClick(async () => {
      this.plugin.settings = Object.assign({}, DEFAULT_SETTINGS);
      await this.plugin.saveSettings();
      this.display();
    }));
  }
};
