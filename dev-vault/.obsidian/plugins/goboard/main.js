/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GoPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/settings.ts
var DEFAULT_SETTINGS = {
  boardSize: 19,
  stoneSizeRatio: 0.9,
  // 40% от размера ячейки
  lineWidth: 1,
  backgroundColor: "#DCB35C",
  lineColor: "#000000",
  blackStoneColor: "#000000",
  whiteStoneColor: "#FFFFFF",
  showCoordinates: true,
  // по умолчанию координаты включены
  coordinatesColor: "#666666",
  // серый цвет для координат
  coordinatesFontSize: 12,
  // размер шрифта координат
  useThemeColors: true
  // по умолчанию используем цвета темы
};

// src/renderer.ts
var GoBoardRenderer = class {
  constructor(settings) {
    this.settings = settings;
  }
  render(source, containerEl) {
    const game = this.parseGame(source);
    const boardContainer = document.createElement("div");
    boardContainer.classList.add("go-board-container");
    const toolbar = this.createToolbar(source, containerEl);
    boardContainer.appendChild(toolbar);
    const svg = this.generateSVG(game, containerEl);
    this.addClickHandler(svg, game);
    boardContainer.appendChild(svg);
    containerEl.appendChild(boardContainer);
  }
  parseGame(source) {
    const lines = source.trim().split("\n");
    const moves = [];
    let moveNumber = 1;
    let boardSize = this.settings.boardSize;
    let showCoordinates = this.settings.showCoordinates;
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed)
        continue;
      const sizeMatch = trimmed.match(/^size\s+(\d+)x(\d+)$/i);
      if (sizeMatch) {
        const size = parseInt(sizeMatch[1]);
        boardSize = size;
        continue;
      }
      if (trimmed.toLowerCase() === "coordinates on") {
        showCoordinates = true;
        continue;
      }
      if (trimmed.toLowerCase() === "coordinates off") {
        showCoordinates = false;
        continue;
      }
      const match = trimmed.match(/^([BW])\s+([A-T]\d+)$/i);
      if (match) {
        const color = match[1].toUpperCase() === "B" ? "black" : "white";
        const position = match[2].toUpperCase();
        moves.push({
          stone: { color, position },
          moveNumber: moveNumber++
        });
      }
    }
    return {
      moves,
      boardSize,
      showCoordinates
    };
  }
  generateSVG(game, containerEl) {
    const size = 400;
    const cellSize = size / (game.boardSize + 1);
    const stoneRadius = cellSize * this.settings.stoneSizeRatio / 2;
    const themeColors = this.getThemeColors(containerEl);
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("width", size.toString());
    svg.setAttribute("height", size.toString());
    svg.setAttribute("viewBox", `0 0 ${size} ${size}`);
    svg.classList.add("go-board-svg");
    const background = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    background.setAttribute("width", size.toString());
    background.setAttribute("height", size.toString());
    if (this.settings.useThemeColors) {
      background.setAttribute("fill", "var(--background-secondary)");
    } else {
      background.setAttribute("fill", this.settings.backgroundColor);
    }
    svg.appendChild(background);
    for (let i = 1; i <= game.boardSize; i++) {
      const pos = i * cellSize;
      const vLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
      vLine.setAttribute("x1", pos.toString());
      vLine.setAttribute("y1", cellSize.toString());
      vLine.setAttribute("x2", pos.toString());
      vLine.setAttribute("y2", (game.boardSize * cellSize).toString());
      if (this.settings.useThemeColors) {
        vLine.setAttribute("stroke", "var(--text-muted)");
      } else {
        vLine.setAttribute("stroke", this.settings.lineColor);
      }
      vLine.setAttribute("stroke-width", this.settings.lineWidth.toString());
      svg.appendChild(vLine);
      const hLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
      hLine.setAttribute("x1", cellSize.toString());
      hLine.setAttribute("y1", pos.toString());
      hLine.setAttribute("x2", (game.boardSize * cellSize).toString());
      hLine.setAttribute("y2", pos.toString());
      if (this.settings.useThemeColors) {
        hLine.setAttribute("stroke", "var(--text-muted)");
      } else {
        hLine.setAttribute("stroke", this.settings.lineColor);
      }
      hLine.setAttribute("stroke-width", this.settings.lineWidth.toString());
      svg.appendChild(hLine);
    }
    if (game.showCoordinates) {
      this.addCoordinates(svg, game.boardSize, cellSize, themeColors);
    }
    for (const move of game.moves) {
      const pos = this.positionToCoords(move.stone.position, game.boardSize);
      if (pos) {
        const x = (pos.x + 1) * cellSize;
        const y = (pos.y + 1) * cellSize;
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", x.toString());
        circle.setAttribute("cy", y.toString());
        circle.setAttribute("r", stoneRadius.toString());
        if (this.settings.useThemeColors) {
          circle.setAttribute("fill", move.stone.color === "black" ? "var(--text-normal)" : "var(--background-primary)");
          circle.setAttribute("stroke", "var(--text-muted)");
        } else {
          circle.setAttribute("fill", move.stone.color === "black" ? this.settings.blackStoneColor : this.settings.whiteStoneColor);
          circle.setAttribute("stroke", this.settings.lineColor);
        }
        circle.setAttribute("stroke-width", "1");
        svg.appendChild(circle);
      }
    }
    return svg;
  }
  getThemeColors(containerEl) {
    const docStyle = getComputedStyle(document.documentElement);
    const bodyStyle = getComputedStyle(document.body);
    const containerStyle = getComputedStyle(containerEl);
    const getColor = (varName) => {
      let value = docStyle.getPropertyValue(varName).trim();
      if (!value)
        value = bodyStyle.getPropertyValue(varName).trim();
      if (!value)
        value = containerStyle.getPropertyValue(varName).trim();
      return value;
    };
    const themeColors = {
      textNormal: getColor("--text-normal") || "#000000",
      textMuted: getColor("--text-muted") || "#666666",
      textFaint: getColor("--text-faint") || "#999999",
      backgroundPrimary: getColor("--background-primary") || "#ffffff",
      backgroundSecondary: getColor("--background-secondary") || "#f8f8f8",
      interactiveAccent: getColor("--interactive-accent") || "#007acc",
      textAccent: getColor("--text-accent") || "#007acc"
    };
    return themeColors;
  }
  addCoordinates(svg, boardSize, cellSize, themeColors) {
    for (let i = 0; i < boardSize; i++) {
      const x = (i + 1) * cellSize;
      const y = cellSize * 0.5;
      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      text.setAttribute("x", x.toString());
      text.setAttribute("y", y.toString());
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("dominant-baseline", "middle");
      text.setAttribute("font-size", this.settings.coordinatesFontSize.toString());
      if (this.settings.useThemeColors) {
        text.setAttribute("fill", "var(--text-faint)");
      } else {
        text.setAttribute("fill", this.settings.coordinatesColor);
      }
      text.setAttribute("font-family", "Arial, sans-serif");
      text.textContent = String.fromCharCode("A".charCodeAt(0) + i);
      svg.appendChild(text);
    }
    for (let i = 0; i < boardSize; i++) {
      const x = cellSize * 0.5;
      const y = (i + 1) * cellSize;
      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      text.setAttribute("x", x.toString());
      text.setAttribute("y", y.toString());
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("dominant-baseline", "middle");
      text.setAttribute("font-size", this.settings.coordinatesFontSize.toString());
      if (this.settings.useThemeColors) {
        text.setAttribute("fill", "var(--text-faint)");
      } else {
        text.setAttribute("fill", this.settings.coordinatesColor);
      }
      text.setAttribute("font-family", "Arial, sans-serif");
      text.textContent = (i + 1).toString();
      svg.appendChild(text);
    }
  }
  positionToCoords(position, boardSize) {
    const letter = position.charAt(0);
    const number = parseInt(position.slice(1));
    const x = letter.charCodeAt(0) - "A".charCodeAt(0);
    const y = number - 1;
    if (x >= 0 && x < boardSize && y >= 0 && y < boardSize) {
      return { x, y };
    }
    return null;
  }
  addClickHandler(svg, game) {
    svg.style.cursor = "pointer";
    svg.addEventListener("click", (event) => {
      const rect = svg.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const size = 400;
      const cellSize = size / (game.boardSize + 1);
      const boardX = Math.round((x - cellSize) / cellSize);
      const boardY = Math.round((y - cellSize) / cellSize);
      if (boardX >= 0 && boardX < game.boardSize && boardY >= 0 && boardY < game.boardSize) {
        const position = this.coordsToPosition(boardX, boardY);
        const moveNumber = this.getMoveAtPosition(game, boardX, boardY);
        let message = `\u041F\u043E\u0437\u0438\u0446\u0438\u044F: ${position}`;
        if (moveNumber) {
          message += `
\u0425\u043E\u0434: ${moveNumber}`;
          const move = game.moves.find((m) => m.moveNumber === moveNumber);
          if (move) {
            message += `
\u0426\u0432\u0435\u0442: ${move.stone.color === "black" ? "\u0427\u0435\u0440\u043D\u044B\u0439" : "\u0411\u0435\u043B\u044B\u0439"}`;
          }
        } else {
          message += "\n\u041F\u0443\u0441\u0442\u0430\u044F \u043F\u043E\u0437\u0438\u0446\u0438\u044F";
        }
        this.showMessage(message);
      }
    });
  }
  coordsToPosition(x, y) {
    const letter = String.fromCharCode("A".charCodeAt(0) + x);
    const number = y + 1;
    return `${letter}${number}`;
  }
  getMoveAtPosition(game, x, y) {
    for (const move of game.moves) {
      const pos = this.positionToCoords(move.stone.position, game.boardSize);
      if (pos && pos.x === x && pos.y === y) {
        return move.moveNumber;
      }
    }
    return null;
  }
  showMessage(message) {
    const modal = document.createElement("div");
    modal.style.cssText = `
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background: var(--background-primary, #ffffff);
			border: 2px solid var(--text-accent, #007acc);
			border-radius: 8px;
			padding: 20px;
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
			z-index: 10000;
			font-family: var(--font-text, Arial, sans-serif);
			font-size: 14px;
			color: var(--text-normal, #000000);
			max-width: 300px;
			text-align: center;
			white-space: pre-line;
		`;
    modal.textContent = message;
    const closeButton = document.createElement("button");
    closeButton.textContent = "\u0417\u0430\u043A\u0440\u044B\u0442\u044C";
    closeButton.style.cssText = `
			margin-top: 10px;
			padding: 8px 16px;
			background: var(--interactive-accent, #007acc);
			color: var(--text-on-accent, #ffffff);
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-size: 12px;
		`;
    closeButton.addEventListener("click", () => {
      if (document.body.contains(modal)) {
        document.body.removeChild(modal);
      }
      if (document.body.contains(overlay)) {
        document.body.removeChild(overlay);
      }
    });
    modal.appendChild(closeButton);
    const overlay = document.createElement("div");
    overlay.style.cssText = `
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.5);
			z-index: 9999;
		`;
    overlay.addEventListener("click", () => {
      if (document.body.contains(overlay)) {
        document.body.removeChild(overlay);
      }
      if (document.body.contains(modal)) {
        document.body.removeChild(modal);
      }
    });
    document.body.appendChild(overlay);
    document.body.appendChild(modal);
  }
  createToolbar(source, containerEl) {
    return this.createToolbarElement(source, containerEl);
  }
  createToolbarElement(source, containerEl) {
    const toolbar = document.createElement("div");
    toolbar.classList.add("go-board-toolbar");
    const clearButton = document.createElement("button");
    clearButton.textContent = "\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u044C";
    clearButton.classList.add("go-board-clear-button");
    clearButton.addEventListener("click", () => {
      this.clearBoard(source, containerEl);
    });
    toolbar.appendChild(clearButton);
    return toolbar;
  }
  clearBoard(source, containerEl) {
    const codeBlock = containerEl.closest("pre");
    if (codeBlock) {
      const game = this.parseGame(source);
      const newContent = `size ${game.boardSize}x${game.boardSize}`;
      const textarea = codeBlock.querySelector("textarea");
      if (textarea) {
        textarea.value = newContent;
        textarea.dispatchEvent(new Event("input", { bubbles: true }));
      }
    }
  }
};

// src/main.ts
var GoPlugin = class extends import_obsidian.Plugin {
  async onload() {
    console.log("GoBoard: Plugin loading...");
    await this.loadSettings();
    this.renderer = new GoBoardRenderer(this.settings);
    this.registerMarkdownCodeBlockProcessor("goboard", (source, el, ctx) => {
      console.log("GoBoard: Processing goboard code block");
      this.renderer.render(source, el);
    });
    this.addSettingTab(new GoSettingsTab(this.app, this));
    console.log("GoBoard: Plugin loaded successfully!");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.renderer = new GoBoardRenderer(this.settings);
  }
};
var GoSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "GoBoard Settings" });
    new import_obsidian.Setting(containerEl).setName("Board Size").setDesc("Default board size (9, 13, or 19)").addDropdown((dropdown) => dropdown.addOption("9", "9x9").addOption("13", "13x13").addOption("19", "19x19").setValue(this.plugin.settings.boardSize.toString()).onChange(async (value) => {
      this.plugin.settings.boardSize = parseInt(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Use Theme Colors").setDesc("Use colors from the current Obsidian theme").addToggle((toggle) => toggle.setValue(this.plugin.settings.useThemeColors).onChange(async (value) => {
      this.plugin.settings.useThemeColors = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    new import_obsidian.Setting(containerEl).setName("Stone Size Ratio").setDesc("Size of stones relative to cell size (0.1-1.0)").addSlider((slider) => slider.setLimits(0.1, 1, 0.1).setValue(this.plugin.settings.stoneSizeRatio).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.stoneSizeRatio = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Line Width").setDesc("Thickness of board lines").addSlider((slider) => slider.setLimits(0.5, 3, 0.5).setValue(this.plugin.settings.lineWidth).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.lineWidth = value;
      await this.plugin.saveSettings();
    }));
    if (!this.plugin.settings.useThemeColors) {
      new import_obsidian.Setting(containerEl).setName("Background Color").setDesc("Color of the board background").addColorPicker((colorPicker) => colorPicker.setValue(this.plugin.settings.backgroundColor).onChange(async (value) => {
        this.plugin.settings.backgroundColor = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Line Color").setDesc("Color of the board lines").addColorPicker((colorPicker) => colorPicker.setValue(this.plugin.settings.lineColor).onChange(async (value) => {
        this.plugin.settings.lineColor = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Black Stone Color").setDesc("Color of black stones").addColorPicker((colorPicker) => colorPicker.setValue(this.plugin.settings.blackStoneColor).onChange(async (value) => {
        this.plugin.settings.blackStoneColor = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("White Stone Color").setDesc("Color of white stones").addColorPicker((colorPicker) => colorPicker.setValue(this.plugin.settings.whiteStoneColor).onChange(async (value) => {
        this.plugin.settings.whiteStoneColor = value;
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian.Setting(containerEl).setName("Show Coordinates").setDesc("Display coordinates on the board").addToggle((toggle) => toggle.setValue(this.plugin.settings.showCoordinates).onChange(async (value) => {
      this.plugin.settings.showCoordinates = value;
      await this.plugin.saveSettings();
    }));
    if (!this.plugin.settings.useThemeColors) {
      new import_obsidian.Setting(containerEl).setName("Coordinates Color").setDesc("Color of coordinate labels").addColorPicker((colorPicker) => colorPicker.setValue(this.plugin.settings.coordinatesColor).onChange(async (value) => {
        this.plugin.settings.coordinatesColor = value;
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian.Setting(containerEl).setName("Coordinates Font Size").setDesc("Font size of coordinate labels").addSlider((slider) => slider.setLimits(8, 20, 1).setValue(this.plugin.settings.coordinatesFontSize).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.coordinatesFontSize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Reset to Defaults").setDesc("Reset all settings to default values").addButton((button) => button.setButtonText("Reset").setCta().onClick(async () => {
      this.plugin.settings = Object.assign({}, DEFAULT_SETTINGS);
      await this.plugin.saveSettings();
      this.display();
    }));
  }
};
